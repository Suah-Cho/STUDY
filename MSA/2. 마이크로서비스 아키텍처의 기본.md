### 2. 마이크로서비스 아키텍처의 기본
마이크로서비스의 본질은 독립적으로 개발되어 자율적으로 운영되는 소프트웨어 컴포넌트(서비스)와 그것을 조합해서 애플리케이션을 구성하는 설계 방식이다.

**1. 서비스 구조**

![image](https://github.com/Suah-Cho/STUDY/assets/102336763/33313e44-46e0-46a5-a703-98732949041d)

- 서비스
    - 도메인(비즈니스 영역 또는 문제 영역)의 해결 및 구현을 위해 활용하는 소프트웨어 컴포넌트
    - 특정 영역의 문제를 해결하기 위한 비즈니스 로직과 모델(비즈니스 데이터)를 포함하며, 이들을 호출하기 위한 API를 클라이언트에게 제공
- 비즈니스 데이터
    - 데이터베이스 - 마이크로서비스에서는 서비스를 통해 데이터베이스에 접근
    - `서비스가 비즈니스 데이터를 포함한다`는 것은 특정 데이터베이스에 접근하려면 특정 서비스를 통한다는 설계 방침을 채택한 것
    - 불특정 다수의애플리케이션에서 데이터베이스를 공유하는 형태는 마이크로서비스적인 설계가 아니다.
 
**2. 레이어 아키텍처**

![image](https://github.com/Suah-Cho/STUDY/assets/102336763/b7603144-000b-4cdc-b077-9b9e8d98ed6f)


- 레이어 아키텍처란?
    - 레이어란?
        - 계층을 의미
    - 특정 기준에 근거하여 여러 계층을 만들고 그 계층 구조를 따라서 소프트웨어 컴포넌트나 기능을 분류, 관리하는 접근법
- 장점
    - 간단하면서 이해하기 쉽다.
    - 기능 분할이나 구조화를 진행하기 쉬워서 소프트웨어 컴포넌트를 조합해서 개발하는 설계 방식에 적합
- 단점
    - 확장성이 약하다. → 추상적인 것이 구체적인 것에 의존한다.
        
        ⇒ 소프트웨어 컴포넌트가 인프라(기반) 구현에 의존한다.
        
        (통신 프로토콜이나 데이터베이스 같은 인프라가 변경되면 사용자 인터페이스나 애플리케이션에도 영향을 끼쳐서 프로그램을 수정해야 할 가능성 존재)
        
        ⇒ 프로그램은 그대로 유지하고 인프라만 변환한다는 확장성이 결여되어 있다.
        
    - 제어 반전(Inversion of Contrl. IoC)
        - 레이어 아키텍처의 `결점 보완`을 위해 나온 발상
        - 특정 소프트웨어 컴포넌트와 그 컴포넌트를 의존하는 측의 `의존 관계`를 역으로 반전시키는 것
            
            (ex. 웹애플리케이션 프로그램이 특정 통신 프로토콜에 의존하지 않고 통신 프로토콜 구현이나 애플리케이션 프로그램을 호출하는 형태)
            
            - 콜백(callback)
            - 의존성 주입(Dependency Injection)
                - 객체 지향에서 폭넓게 사용 - Spring

**3. 헥새거널 아키텍처**

![image](https://github.com/Suah-Cho/STUDY/assets/102336763/2eec333c-1f48-4391-881a-c57061546427)

- 불특정한 데이터 입출력에 대응할 수 있도록 확장성을 가진다.
- 중심 - 도메인(비즈니스 로직) / 주변 - 도메인을 호출하는 입력 측과 도메인에 의해 실행되는 출력측 존재
- 핵새거널 아키텍처의 가능성의 근원 ⇒ `포트&어댑터`
    - 어댑터
        - 외부 기능과 상호작용하는 역할
        - 외부 기능 단위로 교체 가능
    - 포트
        - 추상화된 프로그래밍 인터페이스를 도메인에 제공하는 것
        - 포트를 사용하여 외부 기능에 접근하는 코드를 도메인 내에 구현해두면, 외부 기능을 변경해도 도메인은 영향을 받지 않는다.
    - 포트&어댑터 구조를 활용 시
        
        → 외부 기능에 의존하지 않는 비즈니스 로직을 설계 및 구현 가능
        
        → 외부 기능 쉽게 교체 가능 ⇒ 확장성 ⬆

**4.레이어 + 핵새거널 아키텍처**
![image](https://github.com/Suah-Cho/STUDY/assets/102336763/df45a97a-803b-4574-b25d-e5650a9e5e4e)

- 레이어 아키텍처-UI계층, 인프라 계층에서 사용하는 드라이버들 ⇒ 핵서거널-포트 & 어댑터
- 애플리케이션 서비스, 도메인 서비스, 인프라 서비스의 일부 ⇒ 핵새거널의 중심 육각형에 위치

**5. 데이터베이스 접근**
- 서비스가 자신이 포함하고 있지 않은 모델에 접근하려면 해당 모델이 속한 서비스를 거쳐서 데이터에 접근해야 한다. (여러 서비스가 하나의 데이터베이스를 공유하면서 직접 접근하는 것은 권장하지 않음-데이터베이스 변경에 대한 배려)
![image](https://github.com/Suah-Cho/STUDY/assets/102336763/c12cc74b-a47b-48bc-b62b-12c2d5fa4b04)


**6. 트랜잭션 처리**
- 로컬 트랜잭션
    - 하나의 트랜잭션 컨텍스트(begin과 commit으로 설정된 범위) 내에 처리 대상 리소스(데이터베이스나 메시지 기반 미들웨어등)를 제한하는 것
    - 예
        - 프로그램 소스 코드에서 begin과 commit으로 구분된 범위에 하나의 데이터베이스만을 처리 대상으로 하는 경우
        - 마이크로서비스 세계에서 각 서비스가 하나의 데이터베이스를 포함하고 트랜잭션 컨텍스트 내에서 해당 데이터베이스만 대상으로 처리하는 경우
- 글로벌 트랜잭션
    - 하나의 트랜잭션 안에서 여러 리소스를 처리하는 트랜잭션
    - 분산 트랜잭션 구조를 사용하여 구현 가능
    - 예
        - 온라인 쇼핑에서 주문 데이터 베이스의 주문 레코드 삽입과 재고 데이터베이스의 재고 준비를 `동시에` 해야하는 경우
- `마이크로서비스에서는 글로벌 트랜잭션 비추천`
    
    → 마이크로서비스에서는 지속적인 사용이 가능한 단순함 추구 → 글로벌 트랜잭션이 초래하는 복잡한 운영 선호X
    
    → 글로벌 트랜잭션이 컴포넌트의 느슨한 결합을 방해할 수 있다.

**7. 데이터베이스 간 동기화**
MSA 적용 시 애플리케이션 + 데이터베이스 분산 배치 → 초분산 컴퓨팅 환경 구축

⇒ 기존보다 작은 단위로 여러 개의 데이터베이스 운영 가능성 존재

- 사가(Saga)
    - 로컬 트랜잭션, 이벤트, 보상 트랜잭션 등의 기술 및 기법을 사용하여 여러 기소스 간 동기화를 취하는 디자인 패턴
    - 최초 서비스 → 최초 데이터베이스 변경 → 메시징 구조 사용하여 이벤트전달 → 두번째 서비스 → 두번째 데이터베이스 변경 → 메시징 구조 사용하여 이벤트 전달 → 세번째 서비스 → 세번째 데이터베이스 변경
    - 보상 트랜잭션
        - 트랜잭션 처리 결과를 원래대로 되돌리기 위해서 정상 처리의 `반대 방향`으로 처리하는 것
        - 장애가 발생한 이상 처리 흐름에 사용
    - `데이터베이스 간 일관성이 향상 유지해야할 때는 적합하지 않다.`
        
        ⇒ 특정 시험에는 동기화 x, 일정 시간 후에 동기화되는 `결과 일관성이 허용되는 경우`에 활용 가능
        
- 사가 패턴 거절 시 → 비즈니스 프로세스를 분석해서 일관성을 해결할 수 있는 방법이 존재하는 지 찾아봐야 한다.
    
    → 비즈니스(도메인) 전문가가 판단

**8. 데이터 결합**

- API 컴포지션
    - 도메인 계층의 집약 서비스와 인프라 계층의 리포지터리 서비스를 통해서 복수의 데이터베이스로부터 얻은 데이터를 애플리케이션 계층에서 인메모리로 결합하는 디자인 패턴
    - 장점
        - 직감적 + 간단 + 설계 및 구현 용이
    - 단점
        - 애플리케이션 운영 환경의 메모리 내에서 결합 → `처리가 메모리에 집중`
            
            ⇒ 시스템 리소스에 큰 부담을 준다. ⇒ 성능 및 확장성에 악영향
            
- CQRS&이벤트 소싱
    - CQRS와 이벤트 소싱은 독립된 디자인 패턴이지만, 조합해서 사용하는 경우가 대부분
    - 데이터 결합 해결책
    - 결과 일관성을 구현하는 새로운 데이터 접근 패턴으로 활용되기도 한다.
    - **CQRS**
        - 데이터 접근 처리를 `갱신형 처리와 참조형 처리로 구분`하고, 각각을 구현하기 위해 독립된 서비스 컴포넌트와 데이터 저장소를 두는 디자인 패턴
            - 갱신형 처리
                - 명령, 즉 데이터 삽입/변경/삭제
                - 안전하고 확실한 트랜잭션 요구
                
                ⇒ 트랜잭션을 기능과 신뢰성 높은 영구적 데이터 저장소
                
            - 참조형 처리
                - 질의, 즉 데이터 검색/취득
                - 빠른 응답 요구
                
                ⇒ 고속 검색 기능을 가진 데이터 스토어를 배치해 최적화된 설계를 실현
                
    - **이벤트 소싱**
        - CQRS에 빠진 갱신형 저장소와 참조형 저장소를 동기화해주는 구조를 해결해주는 것
        - 비즈니스 데이터를 분할하지 않고 그대로 모아 하나의 데이터 저장소에 저장
            - 이벤트 소스 : 데이터 저장소
            - 이벤트 소스는 대상 비즈니스에 있어 단지 하나의 데이터 저장소일 뿐이므로 글로벌 트랜잭션이 필요하지 않다.
            - 모든 비즈니스 이력이 이벤트 소스에 저장되어 있어 비즈니스 감사 데이터로도 의미를 가진다.
            
            ⇒ 이벤트 소스는 비즈니스 데이터와 친화성이 높은 현대판 장부
            
        - 필요에 따라 검색용 데이터 스토어를 준비하고 `메시지 기반 미들웨어`의 비동기 메시징을 사용해 이벤트 소스와 검색용 데이터 저장소를 동기화한다.
    
    ⇒ CQRS와 이벤트 소싱을 조합하면 기술적으로 갱신형 데이터 저장소와 참조형 데이터 저장소를 연동 가능
    
    - 장단점
        
        
        | 장점 | 단점 |
        | --- | --- |
        |- 쿼리 구현의 용이성, 데이터 감시, 접근 제어 구현의 용이성<br> - 서비스 모델링과의 친화성 ⬆ | - 기존 설계 방식과 다른 난해함<br> - 적합한 사용처라는 것을 제대로 검증한 후에 적용해야 한다. |
- 데이터 결합
    - CQRS & 이벤트 소싱
        
        → 필요에 따라 결합된 데이터를 제공하는 뷰를 구현해서 데이터 결합을 실현 가능
        
        → API 컴포지션의 문제 걱정 X ⇒ 데이터 결합 시 API 컴포지션이 잘 맞지 않으면 그 대안책으로 검토하는 것이 좋다.

**9. 서비스 간 연계 (REST와 메시징)**

- REST
    - 클라이언트가 요청을 전송한 후 그에 대한 응답을 기다리는 동기형 프로토콜
    - 복잡하고 오랜 시간 걸리는 처리에는 적합x
        
        ⇒ 동기형 REST는 성능과 확장성에 어려움이 있는 프로토콜
        
- 메시징
    - 단순한 처리 + 복잡하고 무거운 처리 패턴 고려
    - MOM을 통해서 게시자와 구독자가 이벤트를 주고받는 통신 모델
    - 통신 패턴
        - 단방향&비동기형
        - 요청/응답&동기형
        - 요청/응답&비동기형
            
            (비동기형 → 확장성을 요하는 경우에 적합)

