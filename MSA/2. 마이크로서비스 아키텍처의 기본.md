### 마이크로서비스 아키텍처의 기본
마이크로서비스의 본질은 독립적으로 개발되어 자율적으로 운영되는 소프트웨어 컴포넌트(서비스)와 그것을 조합해서 애플리케이션을 구성하는 설계 방식이다.

**1. 서비스 구조**

![image](https://github.com/Suah-Cho/STUDY/assets/102336763/33313e44-46e0-46a5-a703-98732949041d)

- 서비스
    - 도메인(비즈니스 영역 또는 문제 영역)의 해결 및 구현을 위해 활용하는 소프트웨어 컴포넌트
    - 특정 영역의 문제를 해결하기 위한 비즈니스 로직과 모델(비즈니스 데이터)를 포함하며, 이들을 호출하기 위한 API를 클라이언트에게 제공
- 비즈니스 데이터
    - 데이터베이스 - 마이크로서비스에서는 서비스를 통해 데이터베이스에 접근
    - `서비스가 비즈니스 데이터를 포함한다`는 것은 특정 데이터베이스에 접근하려면 특정 서비스를 통한다는 설계 방침을 채택한 것
    - 불특정 다수의애플리케이션에서 데이터베이스를 공유하는 형태는 마이크로서비스적인 설계가 아니다.
 
**2. 레이어 아키텍처**

![image](https://github.com/Suah-Cho/STUDY/assets/102336763/b7603144-000b-4cdc-b077-9b9e8d98ed6f)


- 레이어 아키텍처란?
    - 레이어란?
        - 계층을 의미
    - 특정 기준에 근거하여 여러 계층을 만들고 그 계층 구조를 따라서 소프트웨어 컴포넌트나 기능을 분류, 관리하는 접근법
- 장점
    - 간단하면서 이해하기 쉽다.
    - 기능 분할이나 구조화를 진행하기 쉬워서 소프트웨어 컴포넌트를 조합해서 개발하는 설계 방식에 적합
- 단점
    - 확장성이 약하다. → 추상적인 것이 구체적인 것에 의존한다.
        
        ⇒ 소프트웨어 컴포넌트가 인프라(기반) 구현에 의존한다.
        
        (통신 프로토콜이나 데이터베이스 같은 인프라가 변경되면 사용자 인터페이스나 애플리케이션에도 영향을 끼쳐서 프로그램을 수정해야 할 가능성 존재)
        
        ⇒ 프로그램은 그대로 유지하고 인프라만 변환한다는 확장성이 결여되어 있다.
        
    - 제어 반전(Inversion of Contrl. IoC)
        - 레이어 아키텍처의 `결점 보완`을 위해 나온 발상
        - 특정 소프트웨어 컴포넌트와 그 컴포넌트를 의존하는 측의 `의존 관계`를 역으로 반전시키는 것
            
            (ex. 웹애플리케이션 프로그램이 특정 통신 프로토콜에 의존하지 않고 통신 프로토콜 구현이나 애플리케이션 프로그램을 호출하는 형태)
            
            - 콜백(callback)
            - 의존성 주입(Dependency Injection)
                - 객체 지향에서 폭넓게 사용 - Spring

**3. 헥새거널 아키텍처**

![image](https://github.com/Suah-Cho/STUDY/assets/102336763/2eec333c-1f48-4391-881a-c57061546427)

- 불특정한 데이터 입출력에 대응할 수 있도록 확장성을 가진다.
- 중심 - 도메인(비즈니스 로직) / 주변 - 도메인을 호출하는 입력 측과 도메인에 의해 실행되는 출력측 존재
- 핵새거널 아키텍처의 가능성의 근원 ⇒ `포트&어댑터`
    - 어댑터
        - 외부 기능과 상호작용하는 역할
        - 외부 기능 단위로 교체 가능
    - 포트
        - 추상화된 프로그래밍 인터페이스를 도메인에 제공하는 것
        - 포트를 사용하여 외부 기능에 접근하는 코드를 도메인 내에 구현해두면, 외부 기능을 변경해도 도메인은 영향을 받지 않는다.
    - 포트&어댑터 구조를 활용 시
        
        → 외부 기능에 의존하지 않는 비즈니스 로직을 설계 및 구현 가능
        
        → 외부 기능 쉽게 교체 가능 ⇒ 확장성 ⬆

**4.레이어 + 핵새거널 아키텍처**
![image](https://github.com/Suah-Cho/STUDY/assets/102336763/df45a97a-803b-4574-b25d-e5650a9e5e4e)

- 레이어 아키텍처-UI계층, 인프라 계층에서 사용하는 드라이버들 ⇒ 핵서거널-포트 & 어댑터
- 애플리케이션 서비스, 도메인 서비스, 인프라 서비스의 일부 ⇒ 핵새거널의 중심 육각형에 위치

**5. 데이터베이스 접근**
- 서비스가 자신이 포함하고 있지 않은 모델에 접근하려면 해당 모델이 속한 서비스를 거쳐서 데이터에 접근해야 한다. (여러 서비스가 하나의 데이터베이스를 공유하면서 직접 접근하는 것은 권장하지 않음-데이터베이스 변경에 대한 배려)
![image](https://github.com/Suah-Cho/STUDY/assets/102336763/c12cc74b-a47b-48bc-b62b-12c2d5fa4b04)


**6. 트랜잭션 처리**
- 로컬 트랜잭션
    - 하나의 트랜잭션 컨텍스트(begin과 commit으로 설정된 범위) 내에 처리 대상 리소스(데이터베이스나 메시지 기반 미들웨어등)를 제한하는 것
    - 예
        - 프로그램 소스 코드에서 begin과 commit으로 구분된 범위에 하나의 데이터베이스만을 처리 대상으로 하는 경우
        - 마이크로서비스 세계에서 각 서비스가 하나의 데이터베이스를 포함하고 트랜잭션 컨텍스트 내에서 해당 데이터베이스만 대상으로 처리하는 경우
- 글로벌 트랜잭션
    - 하나의 트랜잭션 안에서 여러 리소스를 처리하는 트랜잭션
    - 분산 트랜잭션 구조를 사용하여 구현 가능
    - 예
        - 온라인 쇼핑에서 주문 데이터 베이스의 주문 레코드 삽입과 재고 데이터베이스의 재고 준비를 `동시에` 해야하는 경우
- `마이크로서비스에서는 글로벌 트랜잭션 비추천`
    
    → 마이크로서비스에서는 지속적인 사용이 가능한 단순함 추구 → 글로벌 트랜잭션이 초래하는 복잡한 운영 선호X
    
    → 글로벌 트랜잭션이 컴포넌트의 느슨한 결합을 방해할 수 있다.

**7. 데이터베이스 간 동기화**
MSA 적용 시 애플리케이션 + 데이터베이스 분산 배치 → 초분산 컴퓨팅 환경 구축

⇒ 기존보다 작은 단위로 여러 개의 데이터베이스 운영 가능성 존재

- 사가(Saga)
    - 로컬 트랜잭션, 이벤트, 보상 트랜잭션 등의 기술 및 기법을 사용하여 여러 기소스 간 동기화를 취하는 디자인 패턴
    - 최초 서비스 → 최초 데이터베이스 변경 → 메시징 구조 사용하여 이벤트전달 → 두번째 서비스 → 두번째 데이터베이스 변경 → 메시징 구조 사용하여 이벤트 전달 → 세번째 서비스 → 세번째 데이터베이스 변경
    - 보상 트랜잭션
        - 트랜잭션 처리 결과를 원래대로 되돌리기 위해서 정상 처리의 `반대 방향`으로 처리하는 것
        - 장애가 발생한 이상 처리 흐름에 사용
    - `데이터베이스 간 일관성이 향상 유지해야할 때는 적합하지 않다.`
        
        ⇒ 특정 시험에는 동기화 x, 일정 시간 후에 동기화되는 `결과 일관성이 허용되는 경우`에 활용 가능
        
- 사가 패턴 거절 시 → 비즈니스 프로세스를 분석해서 일관성을 해결할 수 있는 방법이 존재하는 지 찾아봐야 한다.
    
    → 비즈니스(도메인) 전문가가 판단

**8. 데이터 결합**

**9. 서비스 간 연계**

**10. 서비스화 진행 방법**
